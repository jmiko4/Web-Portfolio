<!DOCTYPE html>
<html>

<head>
    <title>Space Portfolio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        /* Hide scrollbars */
        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            z-index: 1;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 2;
        }
    </style>
</head>

<body>
    <div id="info">Use WASD keys to move, Space and Shift for up and down, and mouse to look around. R will reset the
        ship to its original position</div>
    <div id="overlay">Click to start</div>
    <!-- Include Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Include FontLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002); // Add some fog for depth
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // Create stars
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2
            });

            const stars = [];
            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 1000;
                const y = (Math.random() - 0.5) * 1000;
                const z = (Math.random() - 0.5) * 1000;
                stars.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(stars, 3));
            const starMesh = new THREE.Points(starGeometry, starMaterial);
            scene.add(starMesh);
        }

        createStars();

        // Initialize the FontLoader
        // Declare the font variable in a scope accessible to your functions
        let font;

        // Initialize the FontLoader
        const fontLoader = new THREE.FontLoader();

        // Load the font
        fontLoader.load('https://threejs.org/examples/fonts/gentilis_regular.typeface.json', function (loadedFont) {
            font = loadedFont;

            // Create the initial text after the font is loaded
            createText('Welcome to Justin\'s \n    Portfolio Space', new THREE.Vector3(0, 0, 100),1);
            // Create additional texts
            createText('Explore the Universe', new THREE.Vector3(100, 10, 200),1);
            createText('Discover New Worlds', new THREE.Vector3(-150, -5, 300),1);

            // You can create more texts as needed
        });

        // Load the font and create text
        function createText(textString, position, rotation) {

            // Ensure the font is loaded
            if (!font) {
                console.error('Font not loaded yet.');
                return;
            }

            // Create the TextGeometry
            const textGeometry = new THREE.TextGeometry(textString, {
                font: font,
                size: 5,
                height: .5,
                curveSegments: 12,
                bevelEnabled: false
            });

            // Center the text geometry
            textGeometry.computeBoundingBox();

            if (textGeometry.boundingBox) {
                const bbox = textGeometry.boundingBox;
                const xMid = -0.5 * (bbox.max.x - bbox.min.x);
                const yMid = -0.5 * (bbox.max.y - bbox.min.y);
                const zMid = -0.5 * (bbox.max.z - bbox.min.z);
                textGeometry.translate(xMid, yMid, zMid);
            }

            // Create a MeshStandardMaterial (or any material you prefer)
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);

            // Position the textMesh at the specified position
            textMesh.position.copy(position);

            // Optionally, rotate the text if desired
            textMesh.rotation.y = Math.PI / rotation; // Rotate 45 degrees around Y-axis

            scene.add(textMesh);
        }

        // Variables for the ship and model loader
        let ship;
        let shipModel;
        const loader = new THREE.GLTFLoader();

        // Load the ship model
        loader.load(
            // Path to your model (make sure the path is correct)
            'rocket_ship_-_low_poly/scene.gltf',
            function (gltf) {
                ship = new THREE.Object3D();
                shipModel = gltf.scene;

                // Adjust scale, position, and rotation
                shipModel.scale.set(1, 1, 1);
                shipModel.position.set(0, 0, 0);
                shipModel.rotation.z = .78; // Adjust rotation
                shipModel.rotation.x = 1.15; // Adjust rotation

                ship.add(shipModel);
                scene.add(ship);

                // Camera setup
                ship.add(camera);
                camera.position.set(0, 1.5, -7.5);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                animate();
            },
            function (xhr) {
                // Called while loading is progressing
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                // Called when loading has errors
                console.error('An error happened', error);
            }
        );

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Movement controls
        const moveSpeed = 0.5;
        const rotationSpeed = 0.0005;
        let keypressed = {};

        document.addEventListener('keydown', (e) => {
            keypressed[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keypressed[e.key.toLowerCase()] = false;
        });

        function handleKeys() {
            const delta = moveSpeed * 0.1;

            // Forward and backward
            if (keypressed['w']) {
                ship.translateZ(delta);
            }
            if (keypressed['s']) {
                ship.translateZ(-delta);
            }

            // Left and right strafing
            if (keypressed['a']) {
                ship.translateX(delta);
            }
            if (keypressed['d']) {
                ship.translateX(-delta);
            }

            // Up and down
            if (keypressed[' ']) { // Space key
                ship.translateY(delta);
            }
            if (keypressed['shift']) { // Shift key
                ship.translateY(-delta);
            }

            //Reset to original position
            if (keypressed['r']) {
                ship.position.set(0, 0, 0);
                ship.rotation.set(0, 0, 0);
                yaw = 0;
                pitch = 0;
            }
        }

        // Mouse movement
        let yaw = 0;
        let pitch = 0;

        // Pointer lock setup
        const overlay = document.getElementById('overlay');
        overlay.addEventListener('click', function () {
            overlay.style.display = 'none'; // Hide overlay
            document.body.requestPointerLock();
        });

        function onPointerLockChange() {
            if (document.pointerLockElement === document.body) {
                document.addEventListener('mousemove', onMouseMove, false);
            } else {
                document.removeEventListener('mousemove', onMouseMove, false);
                overlay.style.display = ''; // Show overlay
            }
        }

        function onPointerLockError() {
            overlay.style.display = ''; // Show overlay
            alert('Pointer Lock failed');
        }

        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('pointerlockerror', onPointerLockError, false);

        function onMouseMove(event) {
            if (!ship) return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            yaw -= movementX * rotationSpeed;
            pitch += movementY * rotationSpeed;

            const PI_2 = Math.PI / 2;
            pitch = Math.max(-PI_2, Math.min(PI_2, pitch));

            // Create quaternions for pitch and yaw
            const quaternionPitch = new THREE.Quaternion();
            const quaternionYaw = new THREE.Quaternion();

            // Set up quaternion rotations around the X and Y axes
            quaternionPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch);
            quaternionYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

            // Combine the pitch and yaw rotations
            ship.quaternion.copy(quaternionYaw).multiply(quaternionPitch);
        }

        function animate() {
            requestAnimationFrame(animate);
            handleKeys();
            shipModel.rotation.y += .002;
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>